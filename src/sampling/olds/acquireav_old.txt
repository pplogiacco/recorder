/* -------------------------------------------------------------------------- */
/* MEASURE AEOLIAN VIBRATION
 *
 *                                                                            */
/* -------------------------------------------------------------------------- */


volatile bool _adcReady;
// volatile sample_t Tc; 

void __attribute__((__interrupt__, auto_psv)) _ADC1Interrupt(void) { // , weak

    IFS0bits.AD1IF = 0; // Clear Int flag immediatelly
    _adcReady = true;
}// End ADC

uint16_t acquireAV(sample_t* dbuf, uint16_t nsec, uint16_t maxpoints) {
#ifdef __VAMP1K_TEST
    printf("acquireAV\n");
#endif
#if defined(__HWDEVICE)
    uint16_t ppPoints;
    uint16_t i, pIndex;
    sample_t *pSSBUF = dbuf;
    sample_t Tc, Tpc; //  Period = ( 1 / Freq_INT0 ) * nsample
    bool PPmatch;
    bool pm01, pm12, pu01, pu12;
    point_t points[PP_MAX_POINTS];
    const uint16_t pp_last_point = PP_MAX_POINTS - 1;

    // TMR3 as pulse counter on T3CK pin (SYNCO)
    AV_SYN_SetDigital();
    AV_SYN_SetDigitalInput(); // Input T3CK/RB15 (SYNCO)
    //
    T2CONbits.T32 = 0; // Configure TMR3 16Bit Operation
    T3CON = 0x00; //Timer 3 Control Register
    T3CONbits.TCS = 1; // clock source T3CK pin
    T3CONbits.TCKPS = 0b00; // 1:8 Prescale value ( Fosc/2/8 = 500Khz )
    TMR3 = 0x00; //TMR3 Timer3 Counter Register
    //PR3 = 63; // Synco 38.4 Khz : 8 = 4.8Khz
    //PR3 = 127; // Synco 38.4 Khz : 16 = 2.4Khz
    //PR3 = 191; // Synco 38.4 Khz : 24 = 1.6Khz
    PR3 = 255; // Synco 38.4 Khz : 32 = 1.2Khz
    IFS0bits.T3IF = 0; // Reset Int vector
    IEC0bits.T3IE = 0; // Int call-back disabled (Trig ADC)

    // ____________________________________Input Analog pins
    AV_INP_SetAnalog(); // RA0 AN0 (2 DIP20) VRef+
    AV_INP_SetAnalogInput();
    AV_INN_SetAnalog(); //  RA1 AN1 (3 DIP20) VRef-
    AV_INN_SetAnalogInput();
    // ____________________________________A/D Converter Setup
    AD1CON1bits.ADON = 0; // Converter off
    AD1CON2 = 0; // Inputs are not scanned
    AD1CSSL = 0; // No scan //ADC1MD bit in the PMD1
    // ____________________________________Clock and Conversion Mode
    AD1CON1 = 0x2200; // No operation in Idle mode (ADSIDL=1)
    AD1CON1bits.MODE12 = 1; // Resolution 12 bit
    AD1CON1bits.SSRC = 0x2; // Timer 3 trig ADC
    AD1CON1bits.ASAM = 1; // Auto-Convert ON ( end sampling and start conversion )
    AD1CON1bits.FORM = 0b01; // Samples Format (Decimal result, signed, right-justified)
    // 11 = Fractional result, signed, left-justified
    // 10 = Absolute fractional result, unsigned, left-justified
    // 01 = Decimal result, signed, right-justified
    // 00 = Absolute decimal result, unsigned, right-justified
    // ____________________________________Buffering Mode
    AD1CON2bits.BUFREGEN = 0; // A/D result buffer is treated as a FIFO
    AD1CON2bits.BUFM = 0; // No alternate half-buffer (starts ADCBUF0)
    AD1CON2bits.SMPI = 0; // Interrupts every samples
    // ____________________________________Conversion Timing
    AD1CON3 = 0;
    AD1CON3bits.ADRC = 0; // Clock is derived from the system clock (Tcy= 1/Fcy)
    AD1CON3bits.EXTSAM = 1; // Extended Sampling Time bit
    AD1CON3bits.SAMC = 14; // 16 Auto-Sample Time TAD
    AD1CON3bits.ADCS = 0b010; // 0b00111110; // ADC Clock Select ( 4Tcy=1TAD 250nS*4 = 1uS)
    // 00111111 = 64·TCY = TAD
    // 00000001 = 2·TCY = TAD
    // ____________________________________Input channels & References
    AD1CON5bits.BGREQ = 1; // Band Gap Request bit ( 1 = BGP enabled )
    AD1CON2 = 0; // Inputs are not scanned
    AD1CHS = 0;
    AD1CON2bits.PVCFG = 0b10; // 0b11; // Positive Voltage Reference
    //11 = 4 * Internal VBG(2)
    //10 = 2 * Internal VBG(3)
    //01 = External VREF+
    //00 = AVDD
    AD1CON2bits.NVCFG = 0; // Negative Voltage Reference
    AD1CHSbits.CH0SA = 0; // S/H+ input (00001 = AN1)
    AD1CHSbits.CH0NA = 0b10; // S/H- input (001 = AN0)
    IFS0bits.AD1IF = 0; // Clear A/D conversion interrupt.
    IPC3bits.AD1IP = 2; // High Interrupt Priority
    //
    // -------------
    ADA2200_Enable(); // Power-on: SPI1, Sensor Board LINE1
    // -------------

    _adcReady = false;
    Tc = 0;
    Tpc = 0; //
    pIndex = 0;
    ppPoints = 0;

    //    int point = 0;

    maxpoints--; // Reserve one for last Sample
    setTimeout(nsec, 0);

    IEC0bits.AD1IE = 1; // Enable A/D conversion interrupt
    T3CONbits.TON = 1;
    AD1CON1bits.ADON = 1; // Start ADC
    ADA2200_Synco(true);
    //   !(isTimeout()&&(pIndex==PP_MAX_POINTS) )  
    while ((ppPoints < maxpoints) && !isTimeout()) { // Loop until cycle-time or full filled buffer

        /*
        if (_adcReady) { // New data available
            _adcReady = false;
            //point = (2047 + ADC1BUF0); // Positive
            points[pIndex].A = (2047 + ADC1BUF0); // point
            points[pIndex].T = Tc;
            Tc++; // T = fSynco/16
            pIndex++;

            
//            if (pIndex == 1) {
//             pIndex = 0;
//             printf("%d\n",(int) 2047+ ADC1BUF0);
//            //printf("%d\n", points[0].A);
//            //printf("P(%d,%d) ->", points[0].T, points[0].A);
//            //printf("%d,%d ->", points[0].A, points[1].A);
//            //printf("Df = %d \n", points[1].A - points[0].A);
//            }
             

            if ((pIndex == PP_MAX_POINTS)) { // Matching P-P
                i = 1;
                PPmatch = false;
                while ((++i < pp_last_point) && !PPmatch) {
                    pu01 = (points[i - 1].A == points[i].A);
                    pu12 = (points[i].A == points[i + 1].A);
                    PPmatch = false;
                    if (!(pu01 || pu12)) {   
                        pm01 = (points[i - 1].A > (points[i].A + g_dev.cnf.calibration.av_filter)); // _snr = 30;
                        pm12 = (points[i].A > (points[i + 1].A + g_dev.cnf.calibration.av_filter));
                        PPmatch = (!pm01) != (!pm12);
                    }
                    i++;
                }

                if (PPmatch) { // Save point
         *pSSBUF = (points[i].T - Tpc); // Time
                    Tpc = points[i].T;
                    pSSBUF++;
                    
         *pSSBUF = points[i].A; // Amplitude
                    pSSBUF++;
                    
                    ppPoints++;

                    pIndex = 0;
                    while (++i <= pp_last_point ) {
                        points[pIndex] = points[i];
                        pIndex++;
                    }
                } else {
                    points[0] = points[pp_last_point];
                    pIndex = 1;
                }
            } // Matching P-P

        } else {
            if (Tc == 1 && ppPoints == 0) { // save first Sample T0
         *pSSBUF = points[0].T;
                pSSBUF++;
         *pSSBUF = points[0].A;
                pSSBUF++;
                ppPoints++;
            }
        }// _adcReady
         */


        if (_adcReady) { // New data available
            _adcReady = false;
            points[pIndex].A = (2047 + ADC1BUF0); // Positive point
            points[pIndex].T = Tc;
            pIndex++;
            Tc++; // T = fSynco/16

            if ((pIndex == PP_MAX_POINTS)) { // min 3 points to mach PP

                if (points[0].A == points[1].A) {
                    points[1] = points[2];
                    pIndex = 2;
                } else {
                    if (points[1].A == points[2].A) {
                    pIndex = 2;                        
                    } else {
                        PPmatch = false;
                        pm01 = (points[0].A > (points[1].A + g_dev.cnf.calibration.av_filter)); // _snr = 30;
                        pm12 = (points[1].A > (points[2].A + g_dev.cnf.calibration.av_filter));
                        // PPmatch = (!pm01) != (!pm12);

                        if ((!pm01) != (!pm12)) { // Save PP point
                            *pSSBUF = (points[1].T - Tpc); // Time
                            Tpc = points[1].T;
                            pSSBUF++;

                            *pSSBUF = points[1].A; // Amplitude
                            pSSBUF++;

                            ppPoints++;

                            points[0] = points[2];
                            pIndex = 1;
                        } else {
                            points[0] = points[1];
                            points[1] = points[2];
                            pIndex = 2;
                        }

                    }
                }
            }

        } else {
            if (Tc == 1 && ppPoints == 0) { // save first Sample T0
                *pSSBUF = points[0].T;
                pSSBUF++;
                *pSSBUF = points[0].A;
                pSSBUF++;
                ppPoints++;
            }
        }// _adcReady




    }

    AD1CON1bits.ADON = 0; // Converter Off
    T3CONbits.TON = 0;
    ADA2200_Disable();

    *pSSBUF = points[pp_last_point].T - Tpc; // Last Sample Tn  
    pSSBUF++;
    *pSSBUF = points[pp_last_point].A; // Amplitude
    ppPoints++;
    return (ppPoints);

#else
    *dbuf = 0;
    return (0); // Hardware not supported
#endif   
}