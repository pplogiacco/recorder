#include <xc.h>
#include <math.h>

#include "sampling.h"
#include "../utils.h"


//------------------------------------------------------------------------------
extern sample_t SSBUF[];
//------------------------------------------------------------------------------

unsigned short getMeasure(typeset_t tset, measurement_t *ms, unsigned short nsec) {
    sample_t *PtrSSBUF = SSBUF;

    ms->dtime = 0xFFFF; // get RTC datetime
    ms->ss = SSBUF;
    PtrSSBUF = ms->ss;
    switch (tset) {

        case _SIG0: // Demo signal
            ms->typeset = _SIG0;
            ms->ns = 0x0;
            ms->nss = SS_BUF_SIZE;
            acquireSignal(PtrSSBUF, ms->nss); // Fill buffer, RET: n-acquired
            break;

        case _SS00: // Vamp1K encoder Sub-span oscillation: // Raw sample signal
            break;
    }
    return (0);
}


const float AV_SAMPLE_T = 0.5; // Seconds (2Hz)
#define AV_VXS 2    // Values * sample (2))
#define DEMO_NSS 9
#define DEMO_T  34

const sample_t demo_av[DEMO_NSS][2] = {// A,t,dT
    { 401, 0}, // t0
    { 960, 1}, // t1
    { 2962, 4},
    { 433, 12},
    { 2164, 19},
    { 165, 27},
    { 967, 30},
    { 226, 31}, // t7
    { 1234, 34} // t8
};

unsigned short getMeasure_SIG0(measurement_t *ms, unsigned short nsec) {
    unsigned long t, i, n, dT2, maxsamples;
    sample_t *pSSBUF;

    ms->dtime = 0xFFFF; // get RTC datetime

    ms->ss = SSBUF;
    pSSBUF = ms->ss;
    ms->typeset = _SIG0;

    // Single sample
    ms->ns = 0x2;
    *pSSBUF = 888; // Temperature
    *(pSSBUF + 1) = 555; // WindSpeed
    pSSBUF += 2;
    // Sequenced samples
    ms->nss = ((unsigned long) (((float) (nsec / AV_SAMPLE_T)))) << 1; // 2-values*sample;
    maxsamples = (unsigned long) ((SS_BUF_SIZE >> 1) - (ms->ns));
    if ((ms->nss) > maxsamples) {
        ms->nss = maxsamples;
    }
    *pSSBUF = (sample_t) demo_av[0][1]; //t0
    *(pSSBUF + 1) = (sample_t) demo_av[0][0]; // A0
    pSSBUF += 2;
    t = 0;
    i = 1; // demo_av[1]
    n = 0;

    while (t <= (ms->nss)) {
        if (i == DEMO_NSS) {
            i = 1;
            n++;
        }
        dT2 = ((n * DEMO_T) + demo_av[i][1]) - (demo_av[i - 1][1]+(n * DEMO_T));
        * pSSBUF = (sample_t) dT2; //AV_VXS:T(i)-T(i-1)
        *(pSSBUF + 1) = (sample_t) demo_av[i][0]; //AV_VXS:A(i)
        pSSBUF += 2;
        t++;
        i++;
    }

    /*
    pSSBUF = ms->ss;
    for (i = 0; i < ms->nss; i++) {
        printf("%u , %u \n", *pSSBUF, *(pSSBUF + 1));
        pSSBUF += 2;
        __delay_ms(2);
    }
    __delay_ms(5000);
     */
    return (ms->ns + ms->nss);
}


#ifdef FFT_H
// DEMO SIGNAL (SEQUENCE)
// ----------------------
// fills the buffer with "nss" samples of a demo signal

unsigned short acquireSignal(sample_t *dbuf, unsigned short nss) {
    short x, x1 = 0, inc = 1, sgn = 1;
    for (x = 0; x < nss; x++) {
        *(dbuf + x) = SinTab(x1) * sgn; //use tab
        x1 += inc;
        if (x1 == NTSIN) {
            x1 = NTSIN - 2;
            inc = -1;
        }
        if (x1 < 0) {
            x1 = 0;
            sgn = -1 * sgn;
            inc = 1;
        }
    }
    return nss;
}
#else

unsigned short acquireSignal(sample_t *dbuf, unsigned short nss) {
    return 0;
}
#endif

/* -------------------------------------------------------------------------- */
uint16_t measurementCounter() {

    return 1;
}

/* -------------------------------------------------------------------------- */
bool measurementLoad(uint16_t index, measurement_t * ms) {
    (void) index;
    //getMeasure(_SIG0, ms, 0);
    getMeasure_SIG0(ms, 20);

    return true;
}

/* -------------------------------------------------------------------------- */
bool measurementDelete(uint16_t index) { // ret: 0/Counter
    (void) index;
    return true;
}


