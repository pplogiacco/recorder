













uint16_t acquireAV01(sample_t* dbuf, uint16_t nsec, uint16_t maxpoints, uint16_t adc_pr3, uint16_t av_filter) {

#ifdef __VAMP1K_TEST
    printf("AV\n");
#elif !defined(__SENSOR_BOARD)
    return (0); // Hardware not supported
#endif       

    sample_t *pSSBUF = dbuf;
    uint16_t ppPoints;
    sample_t Tc, Tcp;
    //


    acquireAV_INIT(adc_pr3); // Compute PR3

    ppPoints = 0; // Use first to store <period> and <scale>

#if defined(__VAMP1K_TEST_print_lvdt)

    acquireAV_START(nsec);
    maxpoints--; // Reserve one for last sample
    int i, diff;
    while (_cycletime) { // Loop until cycle-time 

        if (_adcReady) { // New data available
            _adcReady--;
            // =============== BEGIN:READ

            diff = (SCALE_TOUNSIGNED - ADC1BUF0); //  & 0xFFE;
            printf("%d (%d) \n", diff, ADC1BUF0);
#if (0)
            if (AD1CON2bits.SMPI) {
                //diff = (ADC1BUF0 + ADC1BUF1)>>1; //  & 0xFFE;
                diff = 0;
                for (i = 0; i < AD1CON2bits.SMPI; i++) {
                    diff += *(&ADC1BUF0 + i);
                }
                diff /= AD1CON2bits.SMPI;
                printf("%u ", diff);
                /*
            printf("%d ", ADC1BUF0);
            printf("%d (%u) ", diff,AD1CON2bits.SMPI+1);
            for (i = 16; i > 0; i--) {
                printf("%u", ((diff >> i) & 1U));
            }
            printf(" scaled: %u \n", (sample_t) (SCALE_TOUNSIGNED - diff));
                 */

            } else {
                printf("%d scaled %u ", ADC1BUF0, (sample_t) (SCALE_TOUNSIGNED - ADC1BUF0));
            }
#endif

            // =============== END:READ
        }// _adcReady

    }
    acquireAV_STOP();


#elif defined( __AV0PP )

    Tc = 0;
    Tcp = 0;
    pIndex = 0;
    lpm = -1;

    maxpoints--; // Reserve one for last sample
    acquireAV_START(nsec);
    while ((ppPoints < maxpoints) && !isTimeout()) { // Loop until cycle-time or full filled buffer

        if (_adcReady) { // New data available

            // =============== BEGIN:READ

            // ---------------- get samples
            _adcReady--;
            points[pIndex].A = ADC1BUF0; //(SCALE_TOUNSIGNED - ADC1BUF0); // Positive point
            points[pIndex].T = Tc;
            if (pIndex > 0) { // !!! Inizializzare a 2 volte SCALE_... ed elimina IF nel ciclo
                if (abs(points[pIndex].A - points[pIndex - 1].A) < g_dev.cnf.calibration.av_filter) {
                    points[pIndex - 1] = points[pIndex];
                } else {
                    pIndex++;
                }
            } else { // save first sample T=0
                *pSSBUF = points[0].T;
                pSSBUF++;
                *pSSBUF = points[0].A;
                pSSBUF++;
                ppPoints++;
                pIndex++;
            }
            Tc++; // T = fSynco/16
            // ---------------- get samples

            if ((pIndex == 3)) { // min 3 points to mach PP

                // PPmatch = false;
                //pm01 = (points[0].A > (points[1].A + g_dev.cnf.calibration.av_filter)); // _snr = 30;
                //pm12 = (points[1].A > (points[2].A + g_dev.cnf.calibration.av_filter));
                // pm01 = (points[0].A > points[1].A); // On filtered points
                // pm12 = (points[1].A > points[2].A);
                // if ((!pm01) != (!pm12)) { // Save PP point


                pm01 = (points[0].A < points[1].A); // _snr = 30;
                pm12 = (points[1].A < points[2].A);
                if (pm01 != pm12) { // Save PP point

                    if (pm01 == lpm) { // Over the last one ?
                        *(pSSBUF - 2) += (points[1].T - Tcp); // Time
                        Tcp = points[1].T;
                        *(pSSBUF - 1) = points[1].A; // Amplitude
                    } else {
                        *pSSBUF = (points[1].T - Tcp); // Time
                        Tcp = points[1].T;
                        pSSBUF++;
                        *pSSBUF = points[1].A; // Amplitude
                        pSSBUF++;
                        ppPoints++;
                    }
                    points[0] = points[2];
                    pIndex = 1;
                    lpm = pm01;

                } else {
                    points[0] = points[1];
                    points[1] = points[2];
                    pIndex = 2;
                }
            }
            // =============== END:READ
        }// _adcReady
    }

    acquireAV_STOP();

    *pSSBUF = points[pIndex - 1].T - Tcp; // Last Sample Tn  
    pSSBUF++;
    *pSSBUF = points[pIndex - 1].A; // Amplitude
    //ppPoints++;

#elif defined( __AV0NOPP )

    Tc = 0;
    Tcp = 0;
    _TRISB2 = 0;
    _ANSB2 = 0;
    _LATB2 = 0;
    acquireAV_START(nsec);
    while ((ppPoints <= maxpoints) && !isTimeout()) { // Loop until cycle-time or full filled buffer

        if (_adcReady) { // New data available

            // =============== BEGIN:READ
            _adcReady--;
            _LATB2 ^= 1; // IO_LED2_Toggle() 
            *pSSBUF = Tc - Tcp; //-Tcp;
            Tcp = Tc;
            pSSBUF++;
            *pSSBUF = ADC1BUF0; //(SCALE_TOUNSIGNED - ADC1BUF0); // Positive point
            pSSBUF++;
            ppPoints++;
            pIndex++;
            Tc++; // T = fSynco/16
            // =============== END:READ
        }// _adcReady
    }
    ppPoints--;
    acquireAV_STOP();

#elif defined( __AV0ADC_DATAVIS )


    uint16_t adc12bit;
    acquireAV_START(nsec);
    while (1) { //   Loop until cycle-time or full filled buffer

        if (_adcReady) { // New data available
            // =============== BEGIN:READ
            _adcReady--;
            adc12bit = (ADC1BUF0 + ADC1BUF1) >> 1;
            UART2_Write(0x5F);
            UART2_Write(adc12bit & 0xFF);
            UART2_Write(adc12bit >> 8);
            UART2_Write(_adcReady);
            UART2_Write(0xA0);

            //for (txCounter = 0; txCounter < 6; txCounter++) {
            //  UART2_Write(*(prtTx + txCounter));
            //}
            Tc++; // T = fSynco/16
            // =============== END:READ
        }// _adcReady
    }
    acquireAV_STOP();

#endif 
    return (ppPoints - 1);
}

uint16_t acquireAV01(sample_t* dbuf, uint16_t nsec, uint16_t maxpoints, uint16_t adc_pr3, uint16_t av_filter) {

#ifdef __VAMP1K_TEST
    printf("AV\n");
#elif !defined(__SENSOR_BOARD)
    return (0); // Hardware not supported
#endif       

    sample_t *pSSBUF = dbuf;
    uint16_t ppPoints;
    sample_t Tc, Tcp;
    //
    point_t points[3]; // SAMPLING_AV_PBUFFER
    uint16_t pIndex;
    int pm01, pm12, lpm;

    acquireAV_INIT(adc_pr3); // Compute PR3

    ppPoints = 0; // Use first to store <period> and <scale>

#if defined(__VAMP1K_TEST_print_lvdt)

    acquireAV_START(nsec);
    maxpoints--; // Reserve one for last sample
    int i, diff;
    while (_cycletime) { // Loop until cycle-time 

        if (_adcReady) { // New data available
            _adcReady--;
            // =============== BEGIN:READ

            diff = (SCALE_TOUNSIGNED - ADC1BUF0); //  & 0xFFE;
            printf("%d (%d) \n", diff, ADC1BUF0);
#if (0)
            if (AD1CON2bits.SMPI) {
                //diff = (ADC1BUF0 + ADC1BUF1)>>1; //  & 0xFFE;
                diff = 0;
                for (i = 0; i < AD1CON2bits.SMPI; i++) {
                    diff += *(&ADC1BUF0 + i);
                }
                diff /= AD1CON2bits.SMPI;
                printf("%u ", diff);
                /*
            printf("%d ", ADC1BUF0);
            printf("%d (%u) ", diff,AD1CON2bits.SMPI+1);
            for (i = 16; i > 0; i--) {
                printf("%u", ((diff >> i) & 1U));
            }
            printf(" scaled: %u \n", (sample_t) (SCALE_TOUNSIGNED - diff));
                 */

            } else {
                printf("%d scaled %u ", ADC1BUF0, (sample_t) (SCALE_TOUNSIGNED - ADC1BUF0));
            }
#endif

            // =============== END:READ
        }// _adcReady

    }
    acquireAV_STOP();


#elif defined( __AV0PP )

    Tc = 0;
    Tcp = 0;
    pIndex = 0;
    lpm = -1;

    maxpoints--; // Reserve one for last sample
    acquireAV_START(nsec);
    while ((ppPoints < maxpoints) && !isTimeout()) { // Loop until cycle-time or full filled buffer

        if (_adcReady) { // New data available

            // =============== BEGIN:READ

            // ---------------- get samples
            _adcReady--;
            points[pIndex].A = ADC1BUF0; //(SCALE_TOUNSIGNED - ADC1BUF0); // Positive point
            points[pIndex].T = Tc;
            if (pIndex > 0) { // !!! Inizializzare a 2 volte SCALE_... ed elimina IF nel ciclo
                if (abs(points[pIndex].A - points[pIndex - 1].A) < g_dev.cnf.calibration.av_filter) {
                    points[pIndex - 1] = points[pIndex];
                } else {
                    pIndex++;
                }
            } else { // save first sample T=0
                *pSSBUF = points[0].T;
                pSSBUF++;
                *pSSBUF = points[0].A;
                pSSBUF++;
                ppPoints++;
                pIndex++;
            }
            Tc++; // T = fSynco/16
            // ---------------- get samples

            if ((pIndex == 3)) { // min 3 points to mach PP

                // PPmatch = false;
                //pm01 = (points[0].A > (points[1].A + g_dev.cnf.calibration.av_filter)); // _snr = 30;
                //pm12 = (points[1].A > (points[2].A + g_dev.cnf.calibration.av_filter));
                // pm01 = (points[0].A > points[1].A); // On filtered points
                // pm12 = (points[1].A > points[2].A);
                // if ((!pm01) != (!pm12)) { // Save PP point


                pm01 = (points[0].A < points[1].A); // _snr = 30;
                pm12 = (points[1].A < points[2].A);
                if (pm01 != pm12) { // Save PP point

                    if (pm01 == lpm) { // Over the last one ?
                        *(pSSBUF - 2) += (points[1].T - Tcp); // Time
                        Tcp = points[1].T;
                        *(pSSBUF - 1) = points[1].A; // Amplitude
                    } else {
                        *pSSBUF = (points[1].T - Tcp); // Time
                        Tcp = points[1].T;
                        pSSBUF++;
                        *pSSBUF = points[1].A; // Amplitude
                        pSSBUF++;
                        ppPoints++;
                    }
                    points[0] = points[2];
                    pIndex = 1;
                    lpm = pm01;

                } else {
                    points[0] = points[1];
                    points[1] = points[2];
                    pIndex = 2;
                }
            }
            // =============== END:READ
        }// _adcReady
    }

    acquireAV_STOP();

    *pSSBUF = points[pIndex - 1].T - Tcp; // Last Sample Tn  
    pSSBUF++;
    *pSSBUF = points[pIndex - 1].A; // Amplitude
    //ppPoints++;

#elif defined( __AV0NOPP )

    Tc = 0;
    Tcp = 0;
    _TRISB2 = 0;
    _ANSB2 = 0;
    _LATB2 = 0;
    acquireAV_START(nsec);
    while ((ppPoints <= maxpoints) && !isTimeout()) { // Loop until cycle-time or full filled buffer

        if (_adcReady) { // New data available

            // =============== BEGIN:READ
            _adcReady--;
            _LATB2 ^= 1; // IO_LED2_Toggle() 
            *pSSBUF = Tc - Tcp; //-Tcp;
            Tcp = Tc;
            pSSBUF++;
            *pSSBUF = ADC1BUF0; //(SCALE_TOUNSIGNED - ADC1BUF0); // Positive point
            pSSBUF++;
            ppPoints++;
            pIndex++;
            Tc++; // T = fSynco/16
            // =============== END:READ
        }// _adcReady
    }
    ppPoints--;
    acquireAV_STOP();

#elif defined( __AV0ADC_DATAVIS )


    uint16_t adc12bit;
    acquireAV_START(nsec);
    while (1) { //   Loop until cycle-time or full filled buffer

        if (_adcReady) { // New data available
            // =============== BEGIN:READ
            _adcReady--;
            adc12bit = (ADC1BUF0 + ADC1BUF1) >> 1;
            UART2_Write(0x5F);
            UART2_Write(adc12bit & 0xFF);
            UART2_Write(adc12bit >> 8);
            UART2_Write(_adcReady);
            UART2_Write(0xA0);

            //for (txCounter = 0; txCounter < 6; txCounter++) {
            //  UART2_Write(*(prtTx + txCounter));
            //}
            Tc++; // T = fSynco/16
            // =============== END:READ
        }// _adcReady
    }
    acquireAV_STOP();

#endif 
    return (ppPoints - 1);
}