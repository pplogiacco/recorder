
/*
Caution added by Martin L. Buchanan, mlb@backgroundtask.com, Wed 11/16/2005:

If number is the maximum unsigned int value, call it MAX_VAL, then the first 
evaluation of NEXT(n, number), with n == 1, produces an overflow when 
1 + MAX_VAL/1 is evaluated. For an unsigned type the overflow typically 
wraps around and yields zero as the macro result and zero as the 
overall function result.
*/
#include <stdlib.h>

#define NEXT(n, i)  (((n) + (i)/(n)) >> 1)

unsigned int isqrt(int number) {
  unsigned int n  = 1;
  unsigned int n1 = NEXT(n, number);

  while(abs(n1 - n) > 1) {
    n  = n1;
    n1 = NEXT(n, number);
  }
  while(n1*n1 > number)
    n1--;
  return n1;
}
But the following algorithm is many times faster, even when you have hardware multiplication and division.

unsigned long isqrt(unsigned long x)
{
    register unsigned long op, res, one;

    op = x;
    res = 0;

    /* "one" starts at the highest power of four <= than the argument. */
    one = 1 << 30;  /* second-to-top bit set */
    while (one > op) one >>= 2;

    while (one != 0) {
        if (op >= res + one) {
            op -= res + one;
            res += one << 1;  // <-- faster than 2 * one
        }
        res >>= 1;
        one >>= 2;
    }
    return res;
}
For an explanation as to how the previous and following algorithms work, see Integer Square Roots by Jack W. Crenshaw (http://www.embedded.com/98/9802fe2.htm) - specifically, Figure 2 of that article.
The fastest integer square root C algorithm yet is possibly below:

typedef unsigned char       uint8;
typedef unsigned short int  uint16;
typedef unsigned long int   uint32;

...

uint32  // OR uint16 OR uint8
isqrt32 (uint32 n) // OR isqrt16 ( uint16 n ) OR  isqrt8 ( uint8 n ) - respectively [ OR overloaded as isqrt (uint?? n) in C++ ]
{
    register uint32 // OR register uint16 OR register uint8 - respectively
        root, remainder, place;

    root = 0;
    remainder = n;
    place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

    while (place > remainder)
        place = place >> 2;
    while (place)
    {
        if (remainder >= root + place)
        {
            remainder = remainder - root - place;
            root = root + (place << 1);
        }
        root = root >> 1;
        place = place >> 2;
    }
    return root;
}
However, this is completely processor-dependent and maybe compiler-dependent as well. Another very fast algorithm donated by Tristan Muntsinger (Tristan.Muntsinger@gmail.com) is below. It's best to test each one across an expected range of inputs to find the quickest one for your specific application.

unsigned int sqrt32(unsigned long n)
{
    unsigned int c = 0x8000;
    unsigned int g = 0x8000;

    for(;;) {
        if(g*g > n)
            g ^= c;
        c >>= 1;
        if(c == 0)
            return g;
        g |= c;
    }
}

